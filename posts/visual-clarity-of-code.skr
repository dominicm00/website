; SPDX-FileCopyrightText: 2023 Dominic Martinez <dom@dominicm.dev>
;
; SPDX-License-Identifier: CC-BY-SA-4.0

(use-modules (posts)
             (util)
             (syntax-highlight scheme)
             (highlight-python)
             (highlight-assembly))

(post
:title "Visual clarity of code"
:date (make-date* 2022 12 13)
:summary "How can we make code easier to process visually?"

(p [When discussing how easy a programming language is to read or write, we
primarily think about functionality; what abstractions does the language provide
to make programming easier? What's not often mentioned explicitly—even if we
recognize it instinctually—is the visual clarity of the language.])

(p [Take the snippets below:])

(highlighted-code lex-assembly
"mult_by_2:
    addi $sp, $sp, -16
    sw   $ra, 0($sp)
    sw   $s0, 4($sp)
    sw   $s1, 8($sp)
    sw   $s2, 12($sp)

    move $s0, $a0        # $s0 = arr
    lw   $s1, -4($a0)    # $s1 = array size
    li   $s2, 4          # $s2 = 4
    mul  $a0, $s1, $s2
    jal  malloc          # malloc(arr_size * sizeof(int))

    mul  $t1, $s1, $s2   # size in bytes
    add  $t1, $t1, $t0   # address after end of array
    li   $t1, 2          # mult constant

    move $t0, $v0        # $t0 = new array

_loop:
    bge  $s0, $t1, _end  # break if current_addr >= end_addr
    lw   $t2, 0($s0)     # get array value
    mul  $t2, $t2, $t1   # mult by 2
    sw   $t2, 0($t0)     # store array
    addi $s0, $s0, 4     # increment array
    addi $t0, $t0, 4
    j    _loop

_end:
    lw   $ra, 0($sp)
    lw   $s0, 4($sp)
    lw   $s1, 8($sp)
    lw   $s2, 12($sp)
    addi $sp, $sp, -16
    jr   $ra
")

(highlighted-code lex-python
"def mult_by_2(arr):
   return map(lambda x: x * 2, arr)
")

(p [Assembly forces us to deal with the stack, allocation, iteration, and
register management manually, none of which is actually relevant to our problem.
This is why we normally program in higher-level languages. But what about these
two Python snippets? ])

(highlighted-code lex-python
"def mult_by_2(arr):
   return map(lambda x: x * 2, arr)
")

(highlighted-code lex-python
"def mult_by_2(arr):
   return [x * 2 for x in arr]
")

(p [Disregarding performance, you probably chose the last one. We're operating
at the same level of abstraction here: these two snippets map one-to-one.
However, the list comprehension syntax makes it visually clear that we're
mapping elements of a list, and presents the information in a more natural
reading order. We've gained type information and readibility through a bit of
syntax sugar.])

(p [Let's look at a more extreme example:])

(highlighted-code lex-scheme
"(integrate x a b
  (/
    (exp (- (/ (^ x 2) 2)))
    (sqrt (* 2 pi))))
")

(image-with-height "programs-as-forms_latex.png"
                   "integral over normal distribution in mathematical notation"
                   "75px")

(p [Fundamentally, these two snippets represent the same operation at the same
level of abstraction. Yet the mathematical notation visually communicates that:])

(ol
    (li [We're doing math.])
    (li [We're doing an integral from a to b])
    (li [We have a fraction with an exponential term over a constant])
    (li [This is an integral over the normal distribution]))

(p [Teasing this information out of the Lisp program takes a lot more effort.])

(p [Except, well, ,(strong [I lied]). At least a little bit. Because in all
likelihood, you didn't catch ,(em [all]) that information.])

(h2 [Climbing the curve])

(p [Unless you do statistics, you probably didn't recognize that the integral
was over the normal distribution. If you're not familiar with integrals or other
mathematical notation, you might not have the slightest clue what's going on and
are left without even a function name to look up.])

(p [The Lisp snippet has a lower barrier to entry; as long as you know Lisp
syntax (which is famously simple enough to fit on a business card), you can see
what function is applied to what variables/numbers. And if you're lost as to
what ,(inline-code [integrate]) or ,(inline-code [exp]) do, you can look it up
pretty easily. On the other hand, getting a complete picture of the equation is
difficult, and if you can read the mathematical equation you probably find that
syntax much easier to comprehend.])

(p [Every piece of syntax represents a chance to add a visually distinct
operation, but also increases the learning curve—especially for reading code.])

(p [This is (in my opinion) one reason why many find Lisp and APL difficult to
use despite them being such powerful languages. In Lisp, everything has exactly
one visual form, rendering visual processing of the code very difficult. APL's
symbols make it easier to scan for operations, but because it's almost entirely
non-textual and doesn't use other visual demarcations like whitespace, a
massive amount of memorization is necessary.])

(caption
(source-code "life ← {⊃1 ⍵ ∨.∧ 3 4 = +/ +⌿ ¯1 0 1 ∘.⊖ ¯1 0 1 ⌽¨ ⊂⍵}")
[An ,(link "APL implementation" "https://aplwiki.com/wiki/Conway%27s_Game_of_Life")
of Conway's game of life. Impressive stuff—for the three people who understand
it.])

(p [Figuring out how to create programs that are both visual and readable is
important. Math and engineering rely heavily on symbols and visualizations for a
reason; the human brain is an incredibly efficient visual processor, which we neglect
when we adopt a single syntax for every problem domain. In general purpose
languages, all code devolves into a series of functions and control statements,
regardless of the code's meaning.])

(p [Imagine if there was an easily recognizable syntax for accessing a database,
or logging a block of code. Every hint we give to our pattern recognition system
makes understanding code easier, and we should take advantage of it.])

(p [So let's take a look at the practical challenges of visual programming
representation and how we might approach them.])

(h2 [Dealing with the domain])

(p [It's not very hard/impossible to have the necessary visual patterns in a
general purpose language out of the box. Common patterns vary between domain,
specific application, and even subapplications. Users need to be able to create
their own syntax to express their architecture.])

(p [Lisp does the functionality part of this pretty well, but due to its limited
syntax misses out on visual clarity. Other languages do some form of this, but
I've not found a language that's truly flexible in terms of program syntax yet.])

(p [But there's good reason even macro-focused languages don't venture here.
Even ignoring techinical challenges like parsing, how would we make such a
language readable to people outside the domain? Due to the wide applicability of
programming, programmers shift between domains more often than in many other
knowledge fields; if it takes a week to learn the application syntax, we can
basically kiss open-source contributions goodbye. We need another solution.])

(h2 [Multiple representations])

(p [Putting a layer of indirection between the canonical program representation
and what the user sees is not unheard of; it's what every
,(link "WYSIWYG" "https://en.wikipedia.org/wiki/WYSIWYG") editor does. In
programming, projects like ,(link "Enso" "https://enso.org/"),
,(link "Smalltalk" "https://squeak.org/"), or even syntax highlighting act as
middlemen between the actual program file and what shows up on the screen. Using
indirection, we can modify what people see to align with their experience level.
A symbolic language like APL could show textual versions of it's operations, or
a textual data science language could show a boxes-and-lines style visual
representation.])

(p [This is similar in spirit to the gradual programming model of
,(link "Hedy" "https://hedy-beta.herokuapp.com/"). The needs of beginners and
experts are different, and switching program representations should accomodate
that.])

(h2 [Language support])

(p [The previous section hints about how we would get this to actually work.
Even with custom syntax, there's a canonical AST that can be used by tooling.
There's even prior work here;
,(link "Tree-sitter" "https://tree-sitter.github.io/tree-sitter/") provides
language-independent syntax higlighting, and
,(link "Tree-edit" "https://github.com/ethan-leba/tree-edit") provides
structural editing on top of that AST.])

(h2 [So what?])

(p [Ok, say you're not convinced that we need better visualizations of code.
What does all this work get us?])

(p [As is often the case when indirection is introduced, a whole lot.])

(p [Bidirectional representations for editing source code are fairly limited,
since you have to maintain complete information over the transformation. But
what if you allowed one-way transformations? You don't really care what AST your
programming language uses under the hood, so what if they just used the same one?])

(p [Now before you yell at me, there are limits here. ASTs usually hold a ,(em
[lot]) of language specific data. But we already have a common indirection for
programming languages: intermediate representations! That's how languages as
wide-ranging as Rust and SML can all use ,(link "LLVM" "https://llvm.org/").])

(p [Intermediate representations are very lossy by design, but we can have
something between the two extremes. The closer in design languages are, the more
information they can share. Maybe we can't have a runtime debugger for compiled
languages, but we probably could for all dynamic ones. Inspecting generated
assembly doesn't make sense for Python but it does in everything from C to
Common Lisp.])

(p [Everytime we start a new language, we start at almost a blank slate.
Debugging, editing, profiling, introspection, toolkits, package management;
every language rebuilds these ideas all over again. Hell, nowadays these tend to
be the killer features of new languages. We should be able to focus on the
language syntax and features—the ,(em [representation]) of the
language—separately from the tooling.])

(p [Having this separation makes it much easier to develop small, easy to reason
about DSLs instead of hammering everything into general purpose languages.])

(p [You can go really far down the rabbit hole with this idea—but I'm going to
save that for (hopefully) a future blog post.])

(h2 [Wrapping up])

(p [Hopefully this post gave you some new insights. This space is massive, and
there's probably a lot of research material out there I'm not aware of. I've
included some further reading below; if there's something cool I'm missing let
me know and I'll add it in!])

(h2 [Further Reading])

(ul
 (li [,(link "Stop writing dead
programs" "https://jackrusher.com/strange-loop-2022/"). A wonderful talk by Jack
Rusher that goes into syntax and visual program representation, among other
topics.])
 (li [,(link "Is it really \"Complex\"? Or did we just make it \"Complicated\"?"
             "https://www.youtube.com/watch?v=ubaX1Smg6pY").
             A famous talk by Alan Kay about using smarter, smaller languages.])
 (li [,(link "Enso" "https://enso.org/"). A data science language with a
boxes-and-lines representation.])
 (li [,(link "Subtext" "https://www.subtext-lang.org/"). A \"programming by example\"
      language with a custom editing UI.]))

)
